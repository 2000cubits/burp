#!/usr/bin/env bash
#
# Run builds and tests on Amazon virtual machines.

prog=$(basename $0)

stopping=0

fail()
{
	echo "$prog failed: $*" 1>&2
	[ "$stopping" = 0 ] && stop_all
	exit 1
}

usage()
{
	echo "usage: $prog tarfile directory" 1>&2
	exit 1
}

tarfile="$1"
directory="$2"
[ -n "$tarfile" ] || usage
[ -n "$directory" ] || usage
[ -f "$tarfile" ] || fail "tarfile $tarfile does not exist"

describe()
{
	local instanceid="$1"
	local what="$2"
	aws ec2 describe-instances --instance-ids "$instanceid" --output text \
		--query "Reservations[*].Instances[*].$what" \
			|| fail "getting $what"
}

get_address()
{
	local instanceid="$1"
	describe "$instanceid" PublicIpAddress \
		|| fail "getting address for $instanceid"
}

get_state()
{
	local instanceid="$1"
	describe "$instanceid" State.Name \
		|| fail "getting state for $instanceid"
}

get_platform()
{
	local instanceid="$1"
	describe "$instanceid" Platform \
		|| fail "getting platform for $instanceid"
}

wait_for_state()
{
	local instanceid="$1"
	local wanted_state="$2"
	i=100
	while [ $i -gt 0 ] ; do
		state=$(get_state "$instanceid")
		echo "$instanceid is $state"
		if [ "$state" = "$wanted_state" ] ; then
			return 0
		fi
		sleep 10
		i=$((i-10))
		echo $i
	done
	return 1
}

signal_to_stop()
{
	local instanceid="$1"
	state=$(get_state $instanceid)
	[ "$state" = "stopped" ] && return
	[ "$state" = "terminated" ] && return
	[ "$state" = "running" ] \
		|| fail "unknown state for $instanceid: $state"
	echo "$instanceid is running, telling it to stop"
	aws ec2 stop-instances --instance-ids "$instanceid" \
		|| fail "stop instance $instanceid"
}

signal_to_start()
{
	local instanceid="$1"
	state=$(get_state $instanceid)
	[ "$state" = "stopped" ] \
		|| fail "$instanceid is not stopped: $state"
	echo "$instanceid is stopped, telling it to start"
	aws ec2 start-instances --instance-ids "$instanceid" \
		|| fail "start instance $instanceid"
}

stop_all()
{
	stopping=1
	echo "$instanceids" | while read i ; do
		signal_to_stop "$i"
	done
	echo "$instanceids" | while read i ; do
		wait_for_state "$i" stopped
	done
	stopping=0
}

start_all()
{
	echo "$instanceids" | while read i ; do
		signal_to_start "$i"
	done
	echo "$instanceids" | while read i ; do
		wait_for_state "$i" running
	done
}

instanceids=$(aws ec2 describe-instances | grep -i InstanceId \
  | while read a b ; do
	x=${b#*\"}
	echo "${x%\"*}"
done)

stop_all
start_all

details=$(echo "$instanceids" | while read i ; do
	ip_address=$(get_address $i)
	platform=$(get_platform $i)
	echo $i $ip_address $platform
done)
echo "$details"
windows=$(echo "$details" | grep windows | cut -f 2 -d " ")
linux=$(echo "$details" | grep -v windows | cut -f 2 -d " ")
echo "  linux: $linux"
echo "windows: $windows"

host="ubuntu@$linux"
ssh_opts="-i /var/lib/jenkins/aws/ubfree.pem -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"

# It is possible for the machine to be up, but for sshd to not yet be running.
# Try multiple times for the initial connect.
attempts=0
attempts_max=20
while true ; do
	ssh $ssh_opts "$host" true && break
	attempts=$((attempts+1))
	[ "$attempts" = "$max_attempts" ] && \
		fail "Could not make initial ssh connection after $attempts"
done

ssh $ssh_opts "$host" "rm -rf $tarfile $directory" \
	|| fail "cleaning linux machine"
scp $ssh_opts "$tarfile" "$host:" \
	|| fail "scp $tarfile to ubuntu"
ssh $ssh_opts "$host" "tar -xvf $tarfile" \
	|| fail "unpacking $tarfile"
ssh $ssh_opts "$host" \
	"cd $directory && ./configure && make test" \
		|| fail "make test"
ssh $ssh_opts "$host" \
	"cd $directory/src/win32 && make && make WIN64=yes" \
		|| fail "building windows installers"
ssh $ssh_opts "$host" \
	"cd $directory/test && ./test_windows64 $linux $windows Administrator" \
		|| fail "running windows tests"
scp -r $ssh_opts "$host:$directory/src/win*/release*/burp-win*installer*.exe" . || fail "copying windows installers"
scp -r $ssh_opts "$host:/tmp/burp-coverage" . || fail "copying code coverage"
ssh $ssh_opts "$host" "rm -rf $tarfile $directory" \
	|| fail "cleaning linux machine"

stop_all

echo "Everything succeeded."

exit 0
